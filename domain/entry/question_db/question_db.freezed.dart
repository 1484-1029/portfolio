// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'question_db.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

Question _$QuestionFromJson(Map<String, dynamic> json) {
  return _Question.fromJson(json);
}

/// @nodoc
mixin _$Question {
  String get sQuestionId => throw _privateConstructorUsedError;
  String get sGenre => throw _privateConstructorUsedError;
  String get sQuestionerId => throw _privateConstructorUsedError;
  String get sQuestionerName => throw _privateConstructorUsedError;
  String get sAnswerId => throw _privateConstructorUsedError;
  String get sAnswerName => throw _privateConstructorUsedError;
  String get sQuestionSentence => throw _privateConstructorUsedError;
  String get sOpenCloesFlg => throw _privateConstructorUsedError;
  String get sAnswerFlg => throw _privateConstructorUsedError;
  String get dtCreateDate => throw _privateConstructorUsedError;
  String get sCreateUser => throw _privateConstructorUsedError;
  String get dtUpdateDate => throw _privateConstructorUsedError;
  String get sUpdateUser => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $QuestionCopyWith<Question> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $QuestionCopyWith<$Res> {
  factory $QuestionCopyWith(Question value, $Res Function(Question) then) =
      _$QuestionCopyWithImpl<$Res, Question>;
  @useResult
  $Res call(
      {String sQuestionId,
      String sGenre,
      String sQuestionerId,
      String sQuestionerName,
      String sAnswerId,
      String sAnswerName,
      String sQuestionSentence,
      String sOpenCloesFlg,
      String sAnswerFlg,
      String dtCreateDate,
      String sCreateUser,
      String dtUpdateDate,
      String sUpdateUser});
}

/// @nodoc
class _$QuestionCopyWithImpl<$Res, $Val extends Question>
    implements $QuestionCopyWith<$Res> {
  _$QuestionCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? sQuestionId = null,
    Object? sGenre = null,
    Object? sQuestionerId = null,
    Object? sQuestionerName = null,
    Object? sAnswerId = null,
    Object? sAnswerName = null,
    Object? sQuestionSentence = null,
    Object? sOpenCloesFlg = null,
    Object? sAnswerFlg = null,
    Object? dtCreateDate = null,
    Object? sCreateUser = null,
    Object? dtUpdateDate = null,
    Object? sUpdateUser = null,
  }) {
    return _then(_value.copyWith(
      sQuestionId: null == sQuestionId
          ? _value.sQuestionId
          : sQuestionId // ignore: cast_nullable_to_non_nullable
              as String,
      sGenre: null == sGenre
          ? _value.sGenre
          : sGenre // ignore: cast_nullable_to_non_nullable
              as String,
      sQuestionerId: null == sQuestionerId
          ? _value.sQuestionerId
          : sQuestionerId // ignore: cast_nullable_to_non_nullable
              as String,
      sQuestionerName: null == sQuestionerName
          ? _value.sQuestionerName
          : sQuestionerName // ignore: cast_nullable_to_non_nullable
              as String,
      sAnswerId: null == sAnswerId
          ? _value.sAnswerId
          : sAnswerId // ignore: cast_nullable_to_non_nullable
              as String,
      sAnswerName: null == sAnswerName
          ? _value.sAnswerName
          : sAnswerName // ignore: cast_nullable_to_non_nullable
              as String,
      sQuestionSentence: null == sQuestionSentence
          ? _value.sQuestionSentence
          : sQuestionSentence // ignore: cast_nullable_to_non_nullable
              as String,
      sOpenCloesFlg: null == sOpenCloesFlg
          ? _value.sOpenCloesFlg
          : sOpenCloesFlg // ignore: cast_nullable_to_non_nullable
              as String,
      sAnswerFlg: null == sAnswerFlg
          ? _value.sAnswerFlg
          : sAnswerFlg // ignore: cast_nullable_to_non_nullable
              as String,
      dtCreateDate: null == dtCreateDate
          ? _value.dtCreateDate
          : dtCreateDate // ignore: cast_nullable_to_non_nullable
              as String,
      sCreateUser: null == sCreateUser
          ? _value.sCreateUser
          : sCreateUser // ignore: cast_nullable_to_non_nullable
              as String,
      dtUpdateDate: null == dtUpdateDate
          ? _value.dtUpdateDate
          : dtUpdateDate // ignore: cast_nullable_to_non_nullable
              as String,
      sUpdateUser: null == sUpdateUser
          ? _value.sUpdateUser
          : sUpdateUser // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$QuestionImplCopyWith<$Res>
    implements $QuestionCopyWith<$Res> {
  factory _$$QuestionImplCopyWith(
          _$QuestionImpl value, $Res Function(_$QuestionImpl) then) =
      __$$QuestionImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String sQuestionId,
      String sGenre,
      String sQuestionerId,
      String sQuestionerName,
      String sAnswerId,
      String sAnswerName,
      String sQuestionSentence,
      String sOpenCloesFlg,
      String sAnswerFlg,
      String dtCreateDate,
      String sCreateUser,
      String dtUpdateDate,
      String sUpdateUser});
}

/// @nodoc
class __$$QuestionImplCopyWithImpl<$Res>
    extends _$QuestionCopyWithImpl<$Res, _$QuestionImpl>
    implements _$$QuestionImplCopyWith<$Res> {
  __$$QuestionImplCopyWithImpl(
      _$QuestionImpl _value, $Res Function(_$QuestionImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? sQuestionId = null,
    Object? sGenre = null,
    Object? sQuestionerId = null,
    Object? sQuestionerName = null,
    Object? sAnswerId = null,
    Object? sAnswerName = null,
    Object? sQuestionSentence = null,
    Object? sOpenCloesFlg = null,
    Object? sAnswerFlg = null,
    Object? dtCreateDate = null,
    Object? sCreateUser = null,
    Object? dtUpdateDate = null,
    Object? sUpdateUser = null,
  }) {
    return _then(_$QuestionImpl(
      sQuestionId: null == sQuestionId
          ? _value.sQuestionId
          : sQuestionId // ignore: cast_nullable_to_non_nullable
              as String,
      sGenre: null == sGenre
          ? _value.sGenre
          : sGenre // ignore: cast_nullable_to_non_nullable
              as String,
      sQuestionerId: null == sQuestionerId
          ? _value.sQuestionerId
          : sQuestionerId // ignore: cast_nullable_to_non_nullable
              as String,
      sQuestionerName: null == sQuestionerName
          ? _value.sQuestionerName
          : sQuestionerName // ignore: cast_nullable_to_non_nullable
              as String,
      sAnswerId: null == sAnswerId
          ? _value.sAnswerId
          : sAnswerId // ignore: cast_nullable_to_non_nullable
              as String,
      sAnswerName: null == sAnswerName
          ? _value.sAnswerName
          : sAnswerName // ignore: cast_nullable_to_non_nullable
              as String,
      sQuestionSentence: null == sQuestionSentence
          ? _value.sQuestionSentence
          : sQuestionSentence // ignore: cast_nullable_to_non_nullable
              as String,
      sOpenCloesFlg: null == sOpenCloesFlg
          ? _value.sOpenCloesFlg
          : sOpenCloesFlg // ignore: cast_nullable_to_non_nullable
              as String,
      sAnswerFlg: null == sAnswerFlg
          ? _value.sAnswerFlg
          : sAnswerFlg // ignore: cast_nullable_to_non_nullable
              as String,
      dtCreateDate: null == dtCreateDate
          ? _value.dtCreateDate
          : dtCreateDate // ignore: cast_nullable_to_non_nullable
              as String,
      sCreateUser: null == sCreateUser
          ? _value.sCreateUser
          : sCreateUser // ignore: cast_nullable_to_non_nullable
              as String,
      dtUpdateDate: null == dtUpdateDate
          ? _value.dtUpdateDate
          : dtUpdateDate // ignore: cast_nullable_to_non_nullable
              as String,
      sUpdateUser: null == sUpdateUser
          ? _value.sUpdateUser
          : sUpdateUser // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$QuestionImpl extends _Question {
  const _$QuestionImpl(
      {required this.sQuestionId,
      required this.sGenre,
      required this.sQuestionerId,
      required this.sQuestionerName,
      required this.sAnswerId,
      required this.sAnswerName,
      required this.sQuestionSentence,
      required this.sOpenCloesFlg,
      required this.sAnswerFlg,
      required this.dtCreateDate,
      required this.sCreateUser,
      required this.dtUpdateDate,
      required this.sUpdateUser})
      : super._();

  factory _$QuestionImpl.fromJson(Map<String, dynamic> json) =>
      _$$QuestionImplFromJson(json);

  @override
  final String sQuestionId;
  @override
  final String sGenre;
  @override
  final String sQuestionerId;
  @override
  final String sQuestionerName;
  @override
  final String sAnswerId;
  @override
  final String sAnswerName;
  @override
  final String sQuestionSentence;
  @override
  final String sOpenCloesFlg;
  @override
  final String sAnswerFlg;
  @override
  final String dtCreateDate;
  @override
  final String sCreateUser;
  @override
  final String dtUpdateDate;
  @override
  final String sUpdateUser;

  @override
  String toString() {
    return 'Question(sQuestionId: $sQuestionId, sGenre: $sGenre, sQuestionerId: $sQuestionerId, sQuestionerName: $sQuestionerName, sAnswerId: $sAnswerId, sAnswerName: $sAnswerName, sQuestionSentence: $sQuestionSentence, sOpenCloesFlg: $sOpenCloesFlg, sAnswerFlg: $sAnswerFlg, dtCreateDate: $dtCreateDate, sCreateUser: $sCreateUser, dtUpdateDate: $dtUpdateDate, sUpdateUser: $sUpdateUser)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$QuestionImpl &&
            (identical(other.sQuestionId, sQuestionId) ||
                other.sQuestionId == sQuestionId) &&
            (identical(other.sGenre, sGenre) || other.sGenre == sGenre) &&
            (identical(other.sQuestionerId, sQuestionerId) ||
                other.sQuestionerId == sQuestionerId) &&
            (identical(other.sQuestionerName, sQuestionerName) ||
                other.sQuestionerName == sQuestionerName) &&
            (identical(other.sAnswerId, sAnswerId) ||
                other.sAnswerId == sAnswerId) &&
            (identical(other.sAnswerName, sAnswerName) ||
                other.sAnswerName == sAnswerName) &&
            (identical(other.sQuestionSentence, sQuestionSentence) ||
                other.sQuestionSentence == sQuestionSentence) &&
            (identical(other.sOpenCloesFlg, sOpenCloesFlg) ||
                other.sOpenCloesFlg == sOpenCloesFlg) &&
            (identical(other.sAnswerFlg, sAnswerFlg) ||
                other.sAnswerFlg == sAnswerFlg) &&
            (identical(other.dtCreateDate, dtCreateDate) ||
                other.dtCreateDate == dtCreateDate) &&
            (identical(other.sCreateUser, sCreateUser) ||
                other.sCreateUser == sCreateUser) &&
            (identical(other.dtUpdateDate, dtUpdateDate) ||
                other.dtUpdateDate == dtUpdateDate) &&
            (identical(other.sUpdateUser, sUpdateUser) ||
                other.sUpdateUser == sUpdateUser));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      sQuestionId,
      sGenre,
      sQuestionerId,
      sQuestionerName,
      sAnswerId,
      sAnswerName,
      sQuestionSentence,
      sOpenCloesFlg,
      sAnswerFlg,
      dtCreateDate,
      sCreateUser,
      dtUpdateDate,
      sUpdateUser);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$QuestionImplCopyWith<_$QuestionImpl> get copyWith =>
      __$$QuestionImplCopyWithImpl<_$QuestionImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$QuestionImplToJson(
      this,
    );
  }
}

abstract class _Question extends Question {
  const factory _Question(
      {required final String sQuestionId,
      required final String sGenre,
      required final String sQuestionerId,
      required final String sQuestionerName,
      required final String sAnswerId,
      required final String sAnswerName,
      required final String sQuestionSentence,
      required final String sOpenCloesFlg,
      required final String sAnswerFlg,
      required final String dtCreateDate,
      required final String sCreateUser,
      required final String dtUpdateDate,
      required final String sUpdateUser}) = _$QuestionImpl;
  const _Question._() : super._();

  factory _Question.fromJson(Map<String, dynamic> json) =
      _$QuestionImpl.fromJson;

  @override
  String get sQuestionId;
  @override
  String get sGenre;
  @override
  String get sQuestionerId;
  @override
  String get sQuestionerName;
  @override
  String get sAnswerId;
  @override
  String get sAnswerName;
  @override
  String get sQuestionSentence;
  @override
  String get sOpenCloesFlg;
  @override
  String get sAnswerFlg;
  @override
  String get dtCreateDate;
  @override
  String get sCreateUser;
  @override
  String get dtUpdateDate;
  @override
  String get sUpdateUser;
  @override
  @JsonKey(ignore: true)
  _$$QuestionImplCopyWith<_$QuestionImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
